module test_mutual_information_common
   use iso_fortran_env, only : real64
   use funit
   use mutual_information
   use cpp_mutual_information
#ifdef CUDA_SUPPORT
   use cuda_mutual_information
#endif
   use test_utils
   implicit none

   ! ---------------------------------------------------------------------------
   ! KsgCountsStrategy test parameter
   ! ---------------------------------------------------------------------------

   @testParameter
   type, extends(AbstractTestParameter) :: KsgCountsStrategyParam
      character(len = :), allocatable :: name
      procedure(ksg_counts_i), pointer, nopass :: ksg_counts_strategy
   contains
      procedure :: toString
   end type KsgCountsStrategyParam

   ! ---------------------------------------------------------------------------
   ! Parameterized test case
   ! ---------------------------------------------------------------------------

   @testCase(constructor = make_mutual_information_fixture, testParameters = {getKsgCountsStrategyParams()})
   type, extends(ParameterizedTestCase) :: mutual_information_fixture
      type(KsgCountsStrategyParam) :: param
      integer :: n_points = 1024
      real(real64), allocatable :: Mx(:), My(:)
   contains
      procedure :: setup
      procedure :: teardown
      procedure :: test_mutual_information_independent
      procedure :: test_analytic_gaussian_ratio
   end type mutual_information_fixture

   interface mutual_information_fixture
      module procedure make_mutual_information_fixture
   end interface

contains

   function make_mutual_information_fixture(param) result(this)
      class(KsgCountsStrategyParam), intent(in) :: param
      type(mutual_information_fixture) :: this
      this%param = param
   end function make_mutual_information_fixture

   function getKsgCountsStrategyParams() result(params)
      type(KsgCountsStrategyParam), allocatable :: params(:)

#ifdef CUDA_SUPPORT
      allocate(params(3))
#else
      allocate(params(2))
#endif

      params(1)%name = "Fortran"
      params(1)%ksg_counts_strategy => f90_ksg_counts

      params(2)%name = "C++"
      params(2)%ksg_counts_strategy => cpp_ksg_counts

#ifdef CUDA_SUPPORT
      params(3)%name    = "CUDA"
      params(3)%ksg_counts_strategy => cuda_ksg_counts
#endif
   end function getKsgCountsStrategyParams

   subroutine setup(this)
      class(mutual_information_fixture), intent(inout) :: this
      allocate(this%Mx(this%n_points))
      allocate(this%My(this%n_points))
   end subroutine

   subroutine teardown(this)
      class(mutual_information_fixture), intent(inout) :: this
      deallocate(this%Mx)
      deallocate(this%My)
   end subroutine

   ! ---------------------------------------------------------------------------
   ! Tests
   ! ---------------------------------------------------------------------------

   @test
   subroutine test_mutual_information_independent(this)
      class(mutual_information_fixture), intent(inout) :: this
      real(real64) :: mi
      type(error_t) :: err

      call generate_independent_arrays(this%Mx, this%My, this%n_points)

      call calc_mutual_information(&
            this%Mx, this%My, this%n_points / 2, mi, err, this%param%ksg_counts_strategy)

      @assertEqual(0.0_real64, mi, tolerance = 0.01_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_mutual_information_analytic_gaussian(this)
      class(mutual_information_fixture), intent(inout) :: this
      integer, parameter :: n_big = 4096
      integer :: k
      real(real64) :: Mx(n_big), My(n_big)
      real(real64) :: mi
      type(error_t) err

      call correlated_gaussian_arrays(Mx, My, n_big, 0.9_real64)

      k = int(n_big * 0.04_real64 + 0.5_real64)

      call calc_mutual_information(Mx, My, k, mi, err, this%param%ksg_counts_strategy)

      @assertEqual(0.830366_real64, mi, tolerance = 0.05_real64)
   end subroutine

   @test
   subroutine test_mutual_information_different_size_vars_fails(this)
      class(mutual_information_fixture), intent(inout) :: this
      integer :: k
      real(real64) :: Mx(10), My(20)
      real(real64) :: mi
      type(error_t) err

      k = 3
      call calc_mutual_information(Mx, My, k, mi, err, this%param%ksg_counts_strategy)

      @assertNotEqual(0, err%code)
   end subroutine

   @test
   subroutine test_mutual_information_k_less_than_one_fails(this)
      class(mutual_information_fixture), intent(inout) :: this
      integer :: k
      real(real64) :: Mx(10), My(10)
      real(real64) :: mi
      type(error_t) err

      k = 0
      call calc_mutual_information(Mx, My, k, mi, err, this%param%ksg_counts_strategy)
      @assertNotEqual(0, err%code)

      k = -1
      call calc_mutual_information(Mx, My, k, mi, err, this%param%ksg_counts_strategy)
      @assertNotEqual(0, err%code)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_analytic_gaussian_ratio(this)
      class(mutual_information_fixture), intent(inout) :: this
      real(real64) :: mi_02, mi_04, mi_06
      integer :: k_02, k_04, k_06
      type(error_t) :: err

      call correlated_gaussian_arrays(this%Mx, this%My, this%n_points, 0.9_real64)

      k_02 = int(this%n_points * 0.02_real64 + 0.5_real64)
      k_04 = int(this%n_points * 0.04_real64 + 0.5_real64)
      k_06 = int(this%n_points * 0.06_real64 + 0.5_real64)

      call calc_mutual_information(this%Mx, this%My, k_02, mi_02, err, this%param%ksg_counts_strategy)
      call calc_mutual_information(this%Mx, this%My, k_04, mi_04, err, this%param%ksg_counts_strategy)
      call calc_mutual_information(this%Mx, this%My, k_06, mi_06, err, this%param%ksg_counts_strategy)

      @assertTrue(mi_02 > mi_04)
      @assertTrue(mi_04 > mi_06)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_generalized_correlation_independent(this)
      class(mutual_information_fixture), intent(inout) :: this
      real(real64) :: gc
      type(error_t) :: err

      call generate_independent_arrays(this%Mx, this%My, this%n_points)

      call calc_generalized_correlation(&
            this%Mx, this%My, this%n_points / 2, gc, err, this%param%ksg_counts_strategy)

      @assertEqual(0.0_real64, gc, tolerance = 0.15_real64)
   end subroutine
   !
   !   ! ---------------------------------------------------------------------------
   !
   @test
   subroutine test_generalized_correlation_non_negative(this)
      class(mutual_information_fixture), intent(inout) :: this
      real(real64) :: gc, pearson_r
      type(error_t) :: err

      call correlated_gaussian_arrays(this%Mx, this%My, this%n_points, -1.0_real64)

      call calc_generalized_correlation(&
            this%Mx, this%My, 4, gc, err, this%param%ksg_counts_strategy)

      pearson_r = pearson_corr(this%Mx, this%My, this%n_points)

      @assertEqual(0.0_real64, gc + pearson_r, tolerance = 0.1_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_generalized_correlation_non_linear(this)
      class(mutual_information_fixture), intent(inout) :: this
      real(real64) :: gc
      type(error_t) :: err

      call sin_cos_arrays(this%Mx, this%My, this%n_points)

      call calc_generalized_correlation(&
            this%Mx, this%My, 4, gc, err, this%param%ksg_counts_strategy)

      @assertEqual(1.0_real64, gc, tolerance = 0.1_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   function toString(this) result(s)
      class(KsgCountsStrategyParam), intent(in) :: this
      character(:), allocatable :: s
      s = this%name
   end function

end module test_mutual_information_common
