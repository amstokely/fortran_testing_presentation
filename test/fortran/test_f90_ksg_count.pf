module test_f90_ksg_count
   use iso_fortran_env, only: real64
   use funit
   use mutual_information
   use test_utils
   implicit none

   @TestCase
   type, extends(TestCase) :: ksg_count_fixture
      real(real64) :: Mx(8)
      real(real64) :: My(8)
   contains
      procedure :: setup
      procedure :: test_max_norm_from_point
      procedure :: test_k_argsort
      procedure :: test_max_neighbor_distance
      procedure :: test_count_neighbors_within_radius
      procedure :: test_complete_ksg_count
   end type ksg_count_fixture

contains

   subroutine setup(this)
      class(ksg_count_fixture), intent(inout) :: this

      this%Mx = [1.0_real64, 4.0_real64, &
            6.0_real64, 3.0_real64, &
            5.0_real64, 2.0_real64, &
            7.0_real64, 8.0_real64]

      this%My = [5.0_real64, 6.0_real64, &
            4.0_real64, 8.0_real64, &
            1.0_real64, 7.0_real64, &
            2.0_real64, 3.0_real64]
   end subroutine setup

   ! --------------------------------------------------------------------------

   @Test
   subroutine test_max_norm_from_point(this)
      class(ksg_count_fixture), intent(inout) :: this

      real(real64), parameter :: expected_dists(8) = &
            [0.0_real64, 3.0_real64, 5.0_real64, 3.0_real64, &
                  4.0_real64, 2.0_real64, 6.0_real64, 7.0_real64]

      real(real64) :: dists(8)

      call max_norm_from_point(this%Mx, this%My, &
            this%Mx(1), this%My(1), dists)

      call assertEqual( &
            expected_dists, dists, &
            tolerance=1.0e-12_real64, &
            message="max_norm_from_point: incorrect Chebyshev distances from (Mx(1),My(1)) to all points" )
   end subroutine

   ! --------------------------------------------------------------------------

   @Test
   subroutine test_k_argsort(this)
      class(ksg_count_fixture), intent(inout) :: this

      real(real64), parameter :: X(8) = &
            [0.0_real64, 3.0_real64, 5.0_real64, 3.0_real64, &
                  4.0_real64, 2.0_real64, 6.0_real64, 7.0_real64]

      integer, parameter :: expected_idxs(4) = [1, 6, 2, 4]
      integer :: idxs(4)

      call k_argsort(X, 4, idxs)

      call assertEqual( &
            expected_idxs, idxs, &
            message="k_argsort: failed to return indices of 4 smallest distances in correct order" )
   end subroutine

   ! --------------------------------------------------------------------------

   @Test
   subroutine test_max_neighbor_distance(this)
      class(ksg_count_fixture), intent(inout) :: this

      integer, parameter :: neighbors(3) = [6, 2, 4]
      real(real64) :: max_dist

      call max_neighbor_distance(this%My, 5.0_real64, neighbors, max_dist)

      call assertEqual( &
            3.0_real64, max_dist, &
            tolerance=1.0e-12_real64, &
            message="max_neighbor_distance: wrong maximum |My - y0| over provided neighbor indices" )
   end subroutine

   ! --------------------------------------------------------------------------

   @Test
   subroutine test_count_neighbors_within_radius(this)
      class(ksg_count_fixture), intent(inout) :: this
      integer :: count

      call count_neighbors_within_radius(this%My, 5.0_real64, 3.0_real64, count)

      call assertEqual( &
            6, count, &
            message="count_neighbors_within_radius: incorrect number of My points within Chebyshev radius r=3 of y0=5" )
   end subroutine

   ! --------------------------------------------------------------------------

   @Test
   subroutine test_complete_ksg_count(this)
      class(ksg_count_fixture), intent(inout) :: this

      integer :: f90_mx_counts, f90_my_counts

      call f90_ksg_count(this%Mx, this%My, 1, 3, f90_mx_counts, f90_my_counts)

      call assertEqual( &
            [3, 6], [f90_mx_counts, f90_my_counts], &
            message="f90_ksg_count: incorrect nx, ny counts for point 1 with k=3 (Chebyshev norm KSG rule)" )
   end subroutine

end module test_f90_ksg_count
