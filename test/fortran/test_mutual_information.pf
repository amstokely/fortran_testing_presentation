module test_mutual_information
   use iso_fortran_env, only: real64
   use funit
   use mutual_information
   use cpp_mutual_information
   use cuda_mutual_information
   use test_utils
   implicit none

   ! ---------------------------------------------------------------------------
   ! Backend test parameter
   ! ---------------------------------------------------------------------------

   @testParameter
   type, extends(AbstractTestParameter) :: BackendParam
      character(len=:), allocatable :: name
      procedure(ksg_counts_i), pointer, nopass :: backend
   contains
      procedure :: toString
   end type BackendParam

   ! ---------------------------------------------------------------------------
   ! Parameterized test case
   ! ---------------------------------------------------------------------------

   @testCase(constructor=make_case, testParameters={getBackendParams()})
   type, extends(ParameterizedTestCase) :: mi_case
      type(BackendParam) :: param
      integer :: n_points = 1024
      real(real64), allocatable :: Mx(:), My(:)
   contains
      procedure :: setup
      procedure :: teardown
   end type mi_case

   interface mi_case
      module procedure make_case
   end interface

contains

   ! ---------------------------------------------------------------------------
   ! Constructor
   ! ---------------------------------------------------------------------------

   function make_case(param) result(this)
      class(BackendParam), intent(in) :: param
      type(mi_case) :: this
      this%param = param
   end function make_case

   ! ---------------------------------------------------------------------------
   ! Backend list
   ! ---------------------------------------------------------------------------

   function getBackendParams() result(params)
      type(BackendParam), allocatable :: params(:)

      allocate(params(3))

      params(1)%name    = "Fortran"
      params(1)%backend => nf90_ksg_counts

      params(2)%name    = "C++"
      params(2)%backend => cpp_ksg_counts

      params(3)%name    = "CUDA"
      params(3)%backend => cuda_ksg_counts
   end function getBackendParams

   ! ---------------------------------------------------------------------------
   ! Setup / Teardown
   ! ---------------------------------------------------------------------------

   subroutine setup(this)
      class(mi_case), intent(inout) :: this
      allocate(this%Mx(this%n_points))
      allocate(this%My(this%n_points))
   end subroutine

   subroutine teardown(this)
      class(mi_case), intent(inout) :: this
      deallocate(this%Mx)
      deallocate(this%My)
   end subroutine

   ! ---------------------------------------------------------------------------
   ! Tests
   ! ---------------------------------------------------------------------------

   @test
   subroutine test_mutual_information_independent(this)
      class(mi_case), intent(inout) :: this
      real(real64) :: mi

      call generate_independent_arrays(this%Mx, this%My, this%n_points)

      call calc_mutual_information( &
            this%Mx, this%My, this%n_points/2, mi, this%param%backend)

      @assertEqual(0.0_real64, mi, tolerance=0.01_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_mutual_information_analytic_gaussian(this)
      class(mi_case), intent(inout) :: this
      integer, parameter :: n_big = 4096
      integer :: k
      real(real64) :: Mx(n_big), My(n_big)
      real(real64) :: mi

      call correlated_gaussian_arrays(Mx, My, n_big, 0.9_real64)

      k = int(n_big*0.04_real64 + 0.5_real64)

      call calc_mutual_information(Mx, My, k, mi, this%param%backend)

      @assertEqual(0.830366_real64, mi, tolerance=0.05_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_analytic_gaussian_ratio(this)
      class(mi_case), intent(inout) :: this
      real(real64) :: mi_02, mi_04, mi_06
      integer :: k_02, k_04, k_06

      call correlated_gaussian_arrays(this%Mx, this%My, this%n_points, 0.9_real64)

      k_02 = int(this%n_points*0.02_real64 + 0.5_real64)
      k_04 = int(this%n_points*0.04_real64 + 0.5_real64)
      k_06 = int(this%n_points*0.06_real64 + 0.5_real64)

      call calc_mutual_information(this%Mx, this%My, k_02, mi_02, this%param%backend)
      call calc_mutual_information(this%Mx, this%My, k_04, mi_04, this%param%backend)
      call calc_mutual_information(this%Mx, this%My, k_06, mi_06, this%param%backend)

      @assertTrue(mi_02 > mi_04)
      @assertTrue(mi_04 > mi_06)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_generalized_correlation_independent(this)
      class(mi_case), intent(inout) :: this
      real(real64) :: gc

      call generate_independent_arrays(this%Mx, this%My, this%n_points)

      call calc_generalized_correlation( &
            this%Mx, this%My, this%n_points/2, gc, this%param%backend)

      @assertEqual(0.0_real64, gc, tolerance=0.15_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_generalized_correlation_non_negative(this)
      class(mi_case), intent(inout) :: this
      real(real64) :: gc, pearson_r

      call correlated_gaussian_arrays(this%Mx, this%My, this%n_points, -1.0_real64)

      call calc_generalized_correlation( &
            this%Mx, this%My, 4, gc, this%param%backend)

      pearson_r = pearson_corr(this%Mx, this%My, this%n_points)

      @assertEqual(0.0_real64, gc + pearson_r, tolerance=0.1_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   @test
   subroutine test_generalized_correlation_non_linear(this)
      class(mi_case), intent(inout) :: this
      real(real64) :: gc

      call sin_cos_arrays(this%Mx, this%My, this%n_points)

      call calc_generalized_correlation( &
            this%Mx, this%My, 4, gc, this%param%backend)

      @assertEqual(1.0_real64, gc, tolerance=0.1_real64)
   end subroutine

   ! ---------------------------------------------------------------------------

   function toString(this) result(s)
      class(BackendParam), intent(in) :: this
      character(:), allocatable :: s
      s = this%name
   end function

end module test_mutual_information
